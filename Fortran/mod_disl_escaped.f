      module mod_disl_escaped

C     Purpose: Reads/writes/stores information about dislocations that have 
C     escaped from continuum (but not into atomistic region), leaving a slip step.
C     Also gives dislocation fields.

C     Newer note/TODO: A paper by Romero et al., MSMSE, 2008 discusses how to
C     implement the escaped fields properly. But, their computational approach
C     is somewhat involved, and the approach discussed below seems to work satisfactorily
C     for a crack specimen.

C     Long note/TODO: Accounting for these fields properly is tricky, and I'm
C     not quite sure my discussion below is completely correct. Regardless, I think the implementation
C     is substantially better than that in the previous version of the code (which, admittedly, is a low bar).

C     The escaped "dislocations" are not real entities, and their purpose
C     is similar, but not identical, to the "ghost" dislocations in the CADD method (see mod_disl_ghost).
C     In the case of ghost dislocations, the goal was to make the FE elasticity problem computationally tractable
C     by subtracting out a field (that satisfies equilibrium) that cancels any displacement
C     discontinuities due to atomistic dislocations that FE would not be able to resolve. In the case of escaped dislocations,
C     the actual, total displacement field has a sharp discontinuity, corresponding to a slip step.
C     So this field must be subtracted off before the elasticity problem can be solved.
C     Afterwards, the field can be added back in.

C     This field is a bit subtle, and I think was incorrectly implemented in the old code.
C     (See dislp.f90 for DD and mod_dd_slip for CADD)
C     First, there's no reason why there should be a u2 term. I think this was a copy/paste error.
C     (There is a similar copy/paste of the term "t", which is never used again.)
C     Second, though, the field b/4 for y > yd and -b/4 for y < yd only works if both dislocations escape,
C     as explained in the long note for subroutine getEscapedDispAtPointSub.
C     There's a third, even subtler error that is quite tricky to resolve satisfactorily.
C     The plastic field should not pass through empty space. So, for instance, in a K-field specimen,
C     the slip step generated by a dislocation that has escaped from the top half of the specimen
C     should only be present in that half of the specimen; it does not create a step
C     in the bottom half. One might try to account for this by starting the branch cut
C     very close to where it escaped, but this doesn't work for angled emission...
C     so, we have to place the dislocation at "infinity".

C     Essentially, what we're trying to do is displace
C     one part of the specimen with respect to the other. This is tricky
C     for non-convex bodies and for multiply connected bodies
C     (the latter of which I still don't have a satisfactory solution for).

C     For the specific case of a cracked specimen, with the crack originally at x = 0, y = 0,
C     and the crack plane extending along y = 0 for x < 0, I've implemented a solution
C     that should work (although it's a bit hokey). It involves determining whether
C     the slip plane that the dislocation lies on intersects the crack surface. If so,
C     the dislocation is assigned to a "region", depending on whether it originated in the upper
C     or lower half of the specimen (upper half = 1; lower half = -1; main body = 0).
C     See also mod_disl_escaped_fields...

C     All of this was satisfactorily handled in the original vdG/Needleman problem
C     because the sample was convex (a rectangle)

      use mod_types, only: dp
      use mod_math, only: normalizeVec, rotateVec2D, tolconst
      use mod_disl_try, only: checkTooManyDisl
      use mod_slip_sys, only: slipsys
      use mod_materials, only: materials
      use mod_fe_elements, only: fematerials
      use mod_misc, only: misc
      use mod_nodes, only: getXYBounds
      use mod_disl_misc, only: dislmisc
      implicit none
      
      private
      public :: escapeddisl, initEscapedDislData, readEscapedDislData,
     &  processEscapedDislData, writeEscapedDislData, box,
     &  addEscapedDislocation, getEscapedPos, getEscapedRegion,
     &  getEscapedRegionCrack, getEscapedDispAtPointAll,
     &  getEscapedDispAtPoint, getEscapedDispAtPointSub, getMaxLen,
     &  getEscapedDispAtPointCrack, getEscapedDispAtPointCrackSub
          
      type escapeddislt
C     read-in
      integer :: cut
      real(dp) :: posn(2)
      integer :: region ! used in crack problem; see above. Can be set arbitrarily if not crack problem.
      integer :: sgn
      integer :: slipsys
      end type
        
      type escapeddisldata
C     read-in
      type(escapeddislt), allocatable :: list(:)
C     processed
      integer :: nescapeddisl
      end type
      
      type boxdata
      real(dp) :: maxlen
      end type

      procedure(Dummy), pointer :: getEscapedRegion_ptr => NULL()
      procedure(Dummy2), pointer :: getEscapedDispAtPoint_ptr => NULL()

C     module variables      
      type(escapeddisldata), allocatable :: escapeddisl(:)
      type(boxdata) :: box

C     HARD-CODED CONSTANTS
C     region numbers
      integer, parameter :: regionmainbody = 0
      integer, parameter :: regionuppercrack = 1
      integer, parameter :: regionlowercrack = -1
      real(dp), parameter :: maxlenfac = 2.0_dp ! see getEscapedPos
      
      contains
************************************************************************
      subroutine initEscapedDislData(escapeddislfile)
      
C     Subroutine: initEscapedDislData

C     Inputs: escapeddislfile --- filename where escaped dislocation data is stored
C     (should be something like '[filepref]_escapeddisl')

C     Outputs: None

C     Purpose: Read, initialize data in "escapeddisl" structure, which holds
C     information about escaped dislocations (dislocations that have escaped
C     from continuum, but not into atomistic region, forming a slip step)

      implicit none
      
C     input variables
      character(len=*) :: escapeddislfile
      
      call readEscapedDislData(escapeddislfile)
      call processEscapedDislData()
      
      end subroutine initEscapedDislData
************************************************************************
      subroutine readEscapedDislData(escapeddislfile)
      
C     Subroutine: readEscapedDislData

C     Inputs: escapeddislfile --- filename where escaped dislocation data is stored
C     (should be something like '[filepref]_escapeddisl')

C     Outputs: None

C     Purpose: Read escaped dislocation data (positions, etc.) from file,
C     initialize/allocate structures/arrays

C     Notes: Dislocation array is allocated with # of rows equal to
C     , which is a hard-coded constant. If nescapeddisl > ,
C     an error is thrown. An alternative is to reallocate the array
C     every time nescapeddisl > ...

      implicit none
      
C     input variables
      character(len=*) :: escapeddislfile
      
C     local variables
      integer :: iunit
      integer :: i, j, k
      integer :: m, n
      integer :: nfematerials
      
      open(newunit=iunit,file=escapeddislfile)

      read(iunit,*) nfematerials
      allocate(escapeddisl(nfematerials))
      
C     this should be identical to nfematerials from mod_fe_elements!
      do i = 1, nfematerials
          allocate(escapeddisl(i)%list(dislmisc%nmaxescapeddisl(i)))

          read(iunit,*) m          
          do j = 1, m
              read(iunit,*) escapeddisl(i)%list(j)%cut
          end do
          
          read(iunit,*) m, n
          do j = 1, m
              read(iunit,*) (escapeddisl(i)%list(j)%posn(k), k = 1,n)
          end do

          read(iunit,*) m
          do j = 1, m
              read(iunit,*) escapeddisl(i)%list(j)%region
          end do
          
          read(iunit,*) m
          do j = 1, m
              read(iunit,*) escapeddisl(i)%list(j)%sgn
          end do
          
          read(iunit,*) m
          do j = 1, m
              read(iunit,*) escapeddisl(i)%list(j)%slipsys
          end do
          
          escapeddisl(i)%nescapeddisl = m
      end do    
      
      close(iunit)
      
      end subroutine readEscapedDislData
************************************************************************
      subroutine processEscapedDislData()
      
C     Subroutine: processEscapedDislData

C     Inputs: None

C     Outputs: None

C     Purpose: Assign functions to pointers, depending on whether specimen
C     is a crack specimen (in which case computing fields is tricky), or
C     a convex specimen (in which case it's easy). Also assign maxlen,
C     which is the length of the longest line within the specimen
C     (used to place escaped dislocation sufficiently far away from specimen)
      
      implicit none
      
      select case (misc%iscrackproblem)
          case (.true.)
              getEscapedDispAtPoint_ptr => getEscapedDispAtPointCrack
              getEscapedRegion_ptr => getEscapedRegionCrack
          case (.false.) ! otherwise, assume body is convex
              getEscapedDispAtPoint_ptr => getEscapedDispAtPoint
              getEscapedRegion_ptr => getEscapedRegion
      end select
      
      box%maxlen = getMaxLen()
      
      end subroutine processEscapedDislData
************************************************************************
      function getMaxLen() result(maxlen)
      
C     output variables
      real(dp) :: maxlen
      
C     local variables
      real(dp) :: xmin, xmax, ymin, ymax
      real(dp) :: xlen, ylen
      
      call getXYBounds(xmin,xmax,ymin,ymax)
      xlen = xmax - xmin
      ylen = ymax - ymin
      maxlen = sqrt(xlen**2 + ylen**2)      
      
      end function getMaxLen
************************************************************************
      subroutine writeEscapedDislData(escapeddislfile)
      
C     Subroutine: writeEscapedDislData

C     Inputs: escapeddislfile --- filename where data for escaped dislocations is stored
C     (should be something like '[filepref]_escapeddisl')

C     Outputs: None

C     Purpose: Write escaped dislocation data to file (essentially
C     inverse of readEscapedDislData). Useful in creating "restart" file
      
      implicit none
      
C     input variables
      character(len=*) :: escapeddislfile
      
C     local variables
      integer :: iunit
      integer :: i, j, k
      integer :: m, n
      integer :: nfematerials
      
      open(newunit=iunit,file=escapeddislfile)

      nfematerials = size(escapeddisl)
      write(iunit,*) nfematerials
      do i = 1, nfematerials
          m = escapeddisl(i)%nescapeddisl

          write(iunit,*) m
          do j = 1, m
              write(iunit,*) escapeddisl(i)%list(j)%cut
          end do
          write(iunit,*) ''
          
          n = size(escapeddisl(i)%list(1)%posn)
          write(iunit,*) m, n
          do j = 1, m
              write(iunit,*) (escapeddisl(i)%list(j)%posn(k), k = 1,n)
          end do
          write(iunit,*) ''

          write(iunit,*) m          
          do j = 1, m
              write(iunit,*) escapeddisl(i)%list(j)%region
          end do
          write(iunit,*) ''

          write(iunit,*) m          
          do j = 1, m
              write(iunit,*) escapeddisl(i)%list(j)%sgn
          end do
          write(iunit,*) ''

          write(iunit,*) m
          do j = 1, m
              write(iunit,*) escapeddisl(i)%list(j)%slipsys
          end do
          write(iunit,*) ''
          
      end do
      
      close(iunit)
      
      end subroutine writeEscapedDislData
************************************************************************
      subroutine addEscapedDislocation(posnold,posnnew,isys,bsgn,bcut,
     &                                 mnumfe)

C     Subroutine: addEscapedDislocation

C     Inputs: posnold, posnnew --- old, new positions of dislocation that has escaped
C             isys --- slip system for dislocation (in mnumfe)
C             bsgn --- sign of dislocation (+1 or -1)
C             bcut --- branch cut of dislocation (0 if to the left, 1 if to the right)
C             mnumfe --- fe material number of dislocation

C     Outputs: None
      
C     Purpose: Adds escaped dislocation to escaped disl structure. Updates
C     nescapeddisl, checks against nmaxescapeddisl.
      
      implicit none
      
C     input variables
      real(dp) :: posnold(2), posnnew(2)
      integer :: isys
      integer :: bsgn, bcut
      integer :: region
      integer :: mnumfe
      integer :: dislnum
      
C     local variables
      real(dp) :: escapedpos(2)
      integer :: nmax
      
      ! dislocation number
      dislnum = escapeddisl(mnumfe)%nescapeddisl + 1
      nmax = size(escapeddisl(mnumfe)%list)
      call checkTooManyDisl(dislnum,nmax,'escapeddisl')
      
      ! place dislocation at infinity
      escapedpos = getEscapedPos(posnold,posnnew)
      
      ! get dislocation "region" (only relevant for crack problem)
      region = getEscapedRegion_ptr(posnold,posnnew)
      
      escapeddisl(mnumfe)%list(dislnum)%cut = bcut
      escapeddisl(mnumfe)%list(dislnum)%posn = escapedpos
      escapeddisl(mnumfe)%list(dislnum)%sgn = bsgn
      escapeddisl(mnumfe)%list(dislnum)%slipsys = isys
      escapeddisl(mnumfe)%list(dislnum)%region = region
      escapeddisl(mnumfe)%nescapeddisl = dislnum
      
      end subroutine addEscapedDislocation
************************************************************************
      function getEscapedPos(posnold,posnnew) result(escapedpos)

C     Subroutine: getEscapedPos

C     Inputs: posnold, posnnew --- old, new positions of dislocation that has escaped

C     Outputs: escapedpos --- position of escaped dislocation at "infinity"
      
C     Purpose: Compute position at infinity for escaped dislocation
      
      implicit none
      
C     input variables
      real(dp) :: posnold(2), posnnew(2)
      
C     output variables
      real(dp) :: escapedpos(2)
      
C     local variables
      real(dp), allocatable :: dispnorm(:)
      
      dispnorm = normalizeVec(posnnew-posnold)
      escapedpos = posnold + (maxlenfac*box%maxlen)*dispnorm ! add sufficiently large vector in direction of travel
      
      end function getEscapedPos
************************************************************************
      function Dummy(posnold,posnnew) result(region)
      
C     input variables
      real(dp) :: posnold(2), posnnew(2)
      
C     output variables
      integer :: region
      
      end function Dummy
************************************************************************
      function getEscapedRegion(posnold,posnnew) result(region)

C     Function: getEscapedRegion

C     Inputs: posnold, posnnew --- old, new positions of dislocation that has escaped

C     Outputs: region --- region to assign dislocation to (= 0 by default)
      
C     Purpose: Compute region for escaped dislocation (= 0 by default)
      
      implicit none
      
C     input variables
      real(dp) :: posnold(2), posnnew(2)
      
C     output variables
      integer :: region
      
      region = regionmainbody    
      
      end function getEscapedRegion
************************************************************************
      function getEscapedRegionCrack(posnold,posnnew) result(region)

C     Function: getEscapedRegionCrack

C     Inputs: posnold, posnnew --- old, new positions of dislocation that has escaped

C     Outputs: region --- region to assign dislocation to (= 1 for upper strip, -1 for lower strip, 0 for main body)
      
C     Purpose: Compute region for escaped dislocation. 0 if slip plane does not intersect crack plane;
C              1 if it does and dislocation was in upper strip, -1 if it does and dislocation was in lower strip
C              Necessary to prevent spurious cuts from forming on other strip (across crack plane/free surface)

C     Notes/TODO: As explained above, assumes crack plane at y = 0, crack center at x = 0, y = 0

      implicit none
      
C     input variables
      real(dp) :: posnold(2), posnnew(2)
      
C     output variables
      integer :: region
      
C     local variables
      real(dp) :: s
      real(dp) :: ydiff
      real(dp) :: xintersection
      
      ydiff = posnnew(2) - posnold(2)
      if (abs(ydiff) < tolconst) then ! doesn't intersect crack plane (parallel to crack plane)
          region = regionmainbody
      else    
          s = -posnold(2)/ydiff
          xintersection = posnold(1)*(1.0_dp-s) + posnnew(1)*s
          if (xintersection >= 0.0_dp) then
              region = regionmainbody
          else
              if (posnold(2) > 0.0_dp) then
                  region = regionuppercrack
              else
                  region = regionlowercrack
              end if
          end if
      end if
      region = regionmainbody ! FIX
      
      end function getEscapedRegionCrack
************************************************************************
      function getEscapedDispAtPointAll(posn,mnumfe) result(disp)
      
C     Subroutine: getEscapedDispAtPointAll

C     Inputs: posn - 2 by 1 vector of position of point at which displacement is sought
C             mnumfe --- fe material in which point lies 

C     Outputs: disp --- displacement at point (vector, 2 by 1)

C     Purpose: Get displacement at point from *all* escaped dislocations associated with material
      
C     input variables
      real(dp) :: posn(2)
      integer :: mnumfe
      
C     output variables
      real(dp) :: disp(2)
      
C     local variables
      integer :: i
      integer :: mnum
      real(dp) :: dislpos(2)
      integer :: isys
      integer :: bsgn, bcut
      integer :: region
      real(dp) :: cost, sint
      real(dp) :: dispnew(2)
      real(dp) :: burgers
      
C     TODO: check if it is correct to apply these fields just to mnumfe!
      disp = 0.0_dp
      mnum = fematerials%list(mnumfe)
      burgers = materials(mnum)%burgers
      do i = 1, escapeddisl(mnumfe)%nescapeddisl
          dislpos = escapeddisl(mnumfe)%list(i)%posn
          isys = escapeddisl(mnumfe)%list(i)%slipsys
          bsgn = escapeddisl(mnumfe)%list(i)%sgn
          bcut = escapeddisl(mnumfe)%list(i)%cut
          region = escapeddisl(mnumfe)%list(i)%region
          cost = slipsys(mnumfe)%trig(1,isys)
          sint = slipsys(mnumfe)%trig(2,isys)
          dispnew = getEscapedDispAtPoint_ptr(posn,dislpos,
     &                      cost,sint,bsgn,bcut,burgers,region)
          disp = disp + dispnew
      end do
      
      end function getEscapedDispAtPointAll
************************************************************************
      function Dummy2(posn,dislpos,cost,sint,bsgn,bcut,burgers,
     &               region) result(disp)

      implicit none

C     input variables
      real(dp) :: posn(2), dislpos(2)
      real(dp) :: cost,sint
      integer :: bsgn, bcut
      real(dp) :: burgers
      integer :: region
      
C     output variables
      real(dp) :: disp(2)
      
      end function Dummy2
************************************************************************
      function getEscapedDispAtPoint(posn,dislpos,cost,sint,bsgn,bcut,
     &                burgers,region) result(disp)

C     Function: getEscapedDispAtPoint

C     Inputs: posn - 2 by 1 vector of position of point at which displacement is sought
C             dislpos - 2 by 1 vector of position of dislocation
C             cost, sint - trig for angle of dislocation
C             bsgn - sign of dislocation (+1 or -1)
C             bcut - branch cut of dislocation (0 if to the left, 1 if to the right)
C             burgers - burgers vector of dislocation
C             region - dummy argument (not used in this subroutine; see below)
                        
C     Outputs: disp - 2 by 1 vector of displacements of point (in original
C                     coordinate system, *not* dislocation coordinate system)
     
C     Purpose: Compute displacements at point due to a single 
C              escaped edge dislocation.

C     Notes: 'n' in dxn, etc. refers to the 'new' (dislocation)
C            coordinate system; 'o' refers to the old (unrotated) system.
      
      implicit none
      
C     input variables
      real(dp) :: posn(2), dislpos(2)
      real(dp) :: cost, sint
      integer :: bsgn, bcut
      real(dp) :: burgers
      integer :: region
      
C     output variables
      real(dp) :: disp(2)
      
C     local variables
      real(dp) :: dxo, dyo, dxn, dyn
      real(dp) :: uxn, uyn
      
      dxo = posn(1) - dislpos(1)
      dyo = posn(2) - dislpos(2)
      
C     adjust for branch cut (rotate everything by 180 degrees, reverse sign)
      if (bcut /= 0) then
          cost = -cost
          sint = -sint
          bsgn = -bsgn
      end if 
      
C     rotate coordinates into new coordinate system
      call rotateVec2d(cost,sint,dxo,dyo,dxn,dyn)
      
C     not necessary to adjust positions, since disl lies at infinity

C     get (plastic) displacements
      call getEscapedDispAtPointSub(dxn,dyn,bsgn,burgers,uxn,uyn)  
      
C     rotate displacements back (by negative theta)
      call rotateVec2d(cost,-sint,uxn,uyn,disp(1),disp(2))
      
      end function getEscapedDispAtPoint
************************************************************************
      subroutine getEscapedDispAtPointSub(dxn,dyn,bsgn,burgers,uxn,uyn)

C     Subroutine: getEscapedDispAtPointSub

C     Inputs: dxn, dyn - (adjusted) relative coordinates of point w.r.t.
C                         dislocation, in the dislocation coordinate system
C             burgers - burgers vector of dislocation
C             bsgn - sign of dislocation (+1 or -1)
                        
C     Outputs: uxn, uyn - displacements of point due to (edge) escaped dislocation,
C                         in the dislocation coordinate system
     
C     Purpose: Compute displacements at point due to a plastic slip field
C              from "escaped" dislocation

C     Notes: 'n' in dxn, etc. refers to the 'new' (dislocation)
C            coordinate system; 'o' refers to the old (unrotated) system.
C            Also, see long note below about error in original DD code.
      
      implicit none
      
C     input variables
      real(dp) :: dxn, dyn
      integer :: bsgn
      real(dp) :: burgers
      
C     output variables
      real(dp) :: uxn, uyn

C     Long note: I believe this is implemented incorrectly in the original
C     DD code. There, the plastic displacements from an escaped dislocation (i.e.
C     a dislocation that left the material) were b/4 and -b/4 for points
C     above and below the dislocation, respectively, regardless of whether
C     the point was to the right or left of the dislocation. This doesn't seem to
C     make much sense. And, in fact, there appear to be cancelling errors...
C     if one considers a dipole, where one dislocation exits the right side
C     and the other the left, only the right one contributes plastic slip
C     to the body. So, the slip is b/2 on top and -b/2 on bottom. The original
C     DD code gets this result, but only by adding b/4 from both dislocations.
C     This procedure results in errors when only one of the dislocations (not both)
C     have left the body.
      
      if (dxn < 0.0_dp) then
          uxn = sign(0.5_dp*burgers,real(bsgn,dp))
          if (dyn < 0.0_dp) then
              uxn = -uxn
          end if
      else
          uxn = 0.0_dp
      end if
      uyn = 0.0_dp
      
      end subroutine getEscapedDispAtPointSub
************************************************************************
      function getEscapedDispAtPointCrack(posn,dislpos,cost,sint,
     &                 bsgn,bcut,burgers,region) result(disp)

C     Function: getEscapedDispAtPointCrack

C     Inputs: posn - 2 by 1 vector of position of point at which displacement is sought
C             dislpos - 2 by 1 vector of position of dislocation
C             cost, sint - trig for angle of dislocation
C             bsgn - sign of dislocation (+1 or -1)
C             bcut - branch cut of dislocation (0 if to the left, 1 if to the right)
C             burgers - burgers vector of dislocation
C             region - region that dislocation originated from (see note for getRegionDisl in mod_disl_escaped)
                        
C     Outputs: disp - 2 by 1 vector of displacements of point (in original
C                     coordinate system, *not* dislocation coordinate system)
     
C     Purpose: Compute displacements at point due to a single 
C              escaped edge dislocation for a body with a crack centered at (0,0)
C              and with free surfaces at y = 0 for x < 0.

C     Notes: 'n' in dxn, etc. refers to the 'new' (dislocation)
C            coordinate system; 'o' refers to the old (unrotated) system.
      
      implicit none
      
C     input variables
      real(dp) :: posn(2), dislpos(2)
      real(dp) :: cost, sint
      integer :: bsgn, bcut
      real(dp) :: burgers
      integer :: region
      
C     output variables
      real(dp) :: disp(2)
      
C     local variables
      real(dp) :: dxo, dyo, dxn, dyn
      real(dp) :: uxn, uyn
      
      dxo = posn(1) - dislpos(1)
      dyo = posn(2) - dislpos(2)
      
C     adjust for branch cut (rotate everything by 180 degrees, reverse sign)
      if (bcut /= 0) then
          cost = -cost
          sint = -sint
          bsgn = -bsgn
      end if 
      
C     rotate coordinates into new coordinate system
      call rotateVec2d(cost,sint,dxo,dyo,dxn,dyn)
      
C     not necessary to adjust positions, since disl lies at infinity

C     get (plastic) displacements
      call getEscapedDispAtPointCrackSub(dxn,dyn,dislpos(2),posn(2),
     &                            bsgn,burgers,region,uxn,uyn)  
      
C     rotate displacements back (by negative theta)
      call rotateVec2d(cost,-sint,uxn,uyn,disp(1),disp(2))
      
      end function getEscapedDispAtPointCrack
************************************************************************
      subroutine getEscapedDispAtPointCrackSub(dxn,dyn,ydislo,yo,
     &                                   bsgn,burgers,region,uxn,uyn)

C     Subroutine: getEscapedDispAtPointCrackSub

C     Inputs: dxn, dyn - (adjusted) relative coordinates of point w.r.t.
C                         dislocation, in the dislocation coordinate system
C             ydislo - absolute y-coordinate of dislocation
C             yo - absolute y-coordinate of point
C             bsgn - sign of dislocation (+1 or -1)
C             burgers - burgers vector of dislocation
C             region - region that dislocation originated from (see note for getRegionDisl in mod_disl_escaped)
                        
C     Outputs: uxn, uyn - displacements of point due to (edge) escaped dislocation,
C                         in the dislocation coordinate system
     
C     Purpose: Compute displacements at point due to a plastic slip field
C              from "escaped" dislocation for a body with a crack centered at (0,0)
C              and with free surfaces at y = 0 for x < 0.

C     Notes: 'n' in dxn, etc. refers to the 'new' (dislocation)
C            coordinate system; 'o' refers to the old (unrotated) system.
      
      implicit none
      
C     input variables
      real(dp) :: dxn, dyn
      real(dp) :: ydislo
      real(dp) :: yo
      integer :: region
      integer :: bsgn
      real(dp) :: burgers
      
C     output variables
      real(dp) :: uxn, uyn
      
C     local variables
      logical :: belowplane
      
      if (dxn < 0.0_dp) then
          uxn = sign(0.5_dp*burgers,real(bsgn,dp))
          belowplane = (dyn < 0.0_dp)
          if (belowplane) then
              uxn = -uxn
          end if
          
          ! correct uxn based on region, if necessary
          if (region == 1) then ! disl. originated in upper strip
              if (yo < 0.0_dp) then
                  if ((ydislo < 0.0_dp).eqv.(belowplane)) then
                      uxn = -uxn
                  end if
              end if              
          else if (region == -1) then ! lower strip
              if (yo > 0.0_dp) then
                  if ((ydislo > 0.0_dp).eqv.(belowplane)) then
                      uxn = -uxn
                  end if
              end if 
          end if
      else
          uxn = 0.0_dp
      end if
      uyn = 0.0_dp
      
      end subroutine getEscapedDispAtPointCrackSub
************************************************************************
      end module mod_disl_escaped
